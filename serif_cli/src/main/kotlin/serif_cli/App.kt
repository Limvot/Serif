/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package xyz.room409.serif.serif_cli
import com.googlecode.lanterna.SGR
import com.googlecode.lanterna.TextColor
import com.googlecode.lanterna.graphics.TextGraphics
import com.googlecode.lanterna.input.KeyStroke
import com.googlecode.lanterna.input.KeyType
import com.googlecode.lanterna.terminal.DefaultTerminalFactory
import com.googlecode.lanterna.terminal.Terminal
import xyz.room409.serif.serif_shared.*
import xyz.room409.serif.serif_shared.db.DriverFactory
import java.util.concurrent.LinkedBlockingQueue
import kotlin.concurrent.thread

class App {
    val console = System.console()
    val queue = LinkedBlockingQueue<String>()
    var mstate: MatrixState = MatrixLogin()

    // Get factory and "terminal" from lanterna.
    // This will be a platform specfic terminal.
    val terminal: Terminal = DefaultTerminalFactory().createTerminal()
    // This TextGraphics object is what we will write to and then
    // draw on screen when we are done updating it with text.
    val textGraphics: TextGraphics = terminal.newTextGraphics()
    var xpos = 0
    var ypos = 0
    // Storage for the user's entered input
    // so we can print it on refresh/sync
    var input_str = ""

    val version: String
        get() {
            return mstate.version + ", CLI UI"
        }
    fun run() {
        if (console == null) {
            println()
            println("Console was null! Probs running under gradle.")
            println("It doesn't work, and is really irritating")
            println("Try ./run_dist.sh if you're on a Unixy OS")
            println("Otherwise, if you're on Windows, you'll have to manually")
            println("do ./gradlew :serif_cli:assembleDist and then find and")
            println("extract the distribution zip, and then run the batch file")
            println("in the bin folder. Probs best to automate the process")
            println("like run_dist.sh, but I'm not on Windows and can't")
            println("a batch script without a reference. My apologies.")
            println("-Nathan")
            println()
            return
        }

        // Each UI will create it's specific DriverFactory
        // And call this function before the backend can get
        // information out of the database
        Database.initDb(DriverFactory())

        // Private mode is for fullscreen apps that don't disturb scroll back history on exit
        // (think vim)
        terminal.enterPrivateMode()
        terminal.clearScreen()

        // White text, black background
        setColorWB()

        textGraphics.putString(xpos, ypos, "Serif CLI App", SGR.BOLD)
        ypos += 1

        // Write out the buffer
        terminal.flush()

        val getInputToQueue: () -> Unit = { thread(start = true) { queue.add(readInStr()) }; }

        while (true) {
            // We do this little dance so that Kotlin smart cast works and
            // doesn't complain that it might change between the when
            // and the use in the branches.
            mstate = when (val m = mstate) {
                is MatrixLogin -> {
                    printlnStr(m.login_message)
                    val onSync: () -> Unit = { /*println("there was a new sync");*/ queue.add(":refresh"); }
                    val login_prompt = { ->
                        printStr("Username: ")
                        val username = readInStr()
                        printStr("Password: ")
                        val password = readInStr(true)

                        clearScreen()
                        printlnStr("Logging in with username |$username| and a password I won't print...")
                        m.login(username, password, onSync)
                    }

                    val sessions = m.getSessions()
                    for ((idx, u) in sessions.withIndex()) {
                        printlnStr("$idx: $u")
                    }
                    if (sessions.size == 0) {
                        login_prompt()
                    } else {
                        prompt("Input a session number, or :n to login normally> ")
                        val resp = readInStr()
                        if (resp == ":q") {
                            break
                        } else if (resp != ":n") {
                            val i = resp.toIntOrNull()
                            if (i != null && i in (0..sessions.size - 1)) {
                                clearScreen()
                                printlnStr("Logging in with saved session for |${sessions[i]}| ...")
                                m.loginFromSession(sessions[i], onSync)
                            } else {
                                printlnStr("invalid choice $resp, try again")
                                m
                            }
                        } else {
                            login_prompt()
                        }
                    }
                }
                is MatrixRooms -> {
                    printlnStr(m.message)
                    m.rooms.forEachIndexed { i, (id, name) ->
                        printlnStr("$i - $id - $name")
                    }
                    prompt("Input a room number, :refresh, or :q> ")
                    getInputToQueue()
                    val msg = queue.take()
                    if (msg == ":refresh") {
                        clearScreen()
                        m.refresh()
                    } else if (msg == ":q") {
                        clearScreen()
                        m.fake_logout()
                    } else {
                        val selection = msg.toIntOrNull()
                        if (selection != null && selection >= 0 && selection < m.rooms.size) {
                            m.getRoom(m.rooms[selection].first)
                        } else {
                            printlnStr("Bad number $msg, try again")
                            m
                        }
                    }
                }
                is MatrixChatRoom -> {
                    printRoom(m.messages.takeLast(20), m.name)
                    prompt("Message (or :b for back, :refresh for refresh)> ")
                    getInputToQueue()
                    val msg = queue.take()
                    if (msg == ":b") {
                        clearScreen()
                        m.exitRoom()
                    } else if (msg == ":refresh") {
                        m.refresh()
                    } else {
                        reprintLine("...sending msg...")
                        m.sendMessage(msg)
                    }
                }
            }
        }
        terminal.close()
    }

    fun clearScreen() {
        // clear screen and reset position
        terminal.clearScreen()
        xpos = 0
        ypos = 0
    }

    fun setColorWB() {
        // Set Fg/Bg colors
        textGraphics.setForegroundColor(TextColor.ANSI.WHITE)
        textGraphics.setBackgroundColor(TextColor.ANSI.BLACK)
    }

    fun setColorGB() {
        textGraphics.setForegroundColor(TextColor.ANSI.GREEN)
        textGraphics.setBackgroundColor(TextColor.ANSI.BLACK)
    }

    fun reprintLine(s: String) {
        val pos = terminal.getCursorPosition()
        val r = pos.getRow()
        val c = pos.getColumn()
        textGraphics.putString(0, r, s)
        for (i in s.length..c - 1) {
            textGraphics.setCharacter(i, r, ' ')
        }
        terminal.flush()
    }

    fun prompt(s: String) {
        // Print out a prompt and any saved input the user has
        // already typed in
        setColorGB()
        textGraphics.putString(xpos, ypos, s)
        xpos += s.length
        setColorWB()
        textGraphics.putString(xpos, ypos, input_str)
        xpos += input_str.length
        terminal.setCursorPosition(xpos, ypos)
        terminal.flush()
    }
    fun printStr(s: String, isBold: Boolean = false) {
        // Print out a string, not moving to next line
        if (isBold) {
            textGraphics.putString(xpos, ypos, s, SGR.BOLD)
        } else {
            textGraphics.putString(xpos, ypos, s)
        }
        xpos += s.length
        terminal.setCursorPosition(xpos, ypos)
        terminal.flush()
    }

    fun printlnStr(s: String, isBold: Boolean = false) {
        // Print out a string, move to next line
        if (isBold) {
            textGraphics.putString(xpos, ypos, s, SGR.BOLD)
        } else {
            textGraphics.putString(xpos, ypos, s)
        }
        xpos = 0
        ypos += 1
        terminal.setCursorPosition(xpos, ypos)
        terminal.flush()
    }

    fun readInStr(hidden: Boolean = false): String {
        var keyStroke: KeyStroke = terminal.readInput()
        while (keyStroke.getKeyType() != KeyType.Enter) {
            if (keyStroke.getKeyType() != KeyType.Backspace) {
                val c = keyStroke.getCharacter()
                input_str = input_str + c
                if (!hidden) {
                    textGraphics.putString(xpos, ypos, "$input_str")
                    terminal.flush()
                }
            } else {
                if (input_str.length == 0) {
                    input_str = ""
                } else {
                    input_str = input_str.dropLast(1)
                    if (!hidden) {
                        textGraphics.putString(xpos + input_str.length, ypos, " ")
                    }
                    terminal.setCursorPosition(xpos + input_str.length, ypos)
                }
            }
            keyStroke = terminal.readInput()
        }
        // Make a local copy and clear storage for next read
        val ret = input_str
        input_str = ""
        return ret
    }
    fun printRoom(messages: List<Pair<String, String>>, room_id: String) {
        // Start Fresh
        this.clearScreen()

        // Print Header
        printlnStr("==$room_id==", isBold = true)
        textGraphics.drawLine(xpos, ypos, xpos + 20, ypos, '-')
        ypos++

        // print last 20 messages or so
        val maxSenderLen = messages.map { (sender, _message) -> sender.length }.max()
        messages.forEach { (sender, message) ->
            val sender_str = "${sender.padEnd(maxSenderLen!!, ' ')}: "
            printStr(sender_str, isBold = true)
            printlnStr(message)
        }
    }
}

fun main(args: Array<String>) {
    var app = App()
    println("Welcome to " + app.version)
    app.run()
    println("Exiting!")
}
