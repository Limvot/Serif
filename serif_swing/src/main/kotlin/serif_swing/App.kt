/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package xyz.room409.serif.serif_swing
import com.formdev.flatlaf.*
import xyz.room409.serif.serif_shared.*
import xyz.room409.serif.serif_shared.db.DriverFactory
import java.awt.*
import java.awt.image.*
import java.awt.event.*
import java.awt.font.TextAttribute
import java.text.AttributedCharacterIterator
import java.awt.image.BufferedImage
import java.awt.image.DataBufferByte
import java.io.BufferedReader
import java.io.File
import java.io.InputStreamReader
import java.text.AttributedString
import javax.sound.sampled.AudioSystem
import javax.swing.*
import javax.swing.filechooser.*
import javax.swing.text.*
import javax.swing.text.html.HTML
import kotlin.concurrent.thread
import kotlin.math.*

import java.util.Timer
import kotlin.concurrent.fixedRateTimer
import org.jcodec.common.io.NIOUtils
import org.jcodec.api.FrameGrab
import org.jcodec.common.model.Picture
import org.jcodec.common.model.ColorSpace
import org.jcodec.common.DemuxerTrack
import org.jcodec.scale.ColorUtil
import org.jcodec.scale.RgbToBgr
import org.jcodec.scale.Transform

object AudioPlayer {
    var url = ""
    val clip = AudioSystem.getClip()
    fun loadAudio(audio_url: String) {
        if (url != audio_url) {
            clip.stop()
            url = audio_url
            val inputStream = AudioSystem.getAudioInputStream(File(url).getAbsoluteFile())
            clip.open(inputStream)
        }
    }
    fun play() {
        if (clip.isRunning()) {
            clip.stop()
        }
        clip.setFramePosition(0)
        clip.start()
    }
}

class VideoPlayer {
    var url = ""
    var redraw_cell: ()->Unit = { Unit }
    var grab: FrameGrab? = null
    var playing_task = Timer()
    var framerate = 17L
    var playing = false

    fun loadVideo(video_url: String, pic_out: JButton, redraw_cell_in: ()->Unit) {
        redraw_cell = redraw_cell_in
        if (url != video_url) {
            url = video_url
            val file = File(video_url);
            grab = FrameGrab.createFrameGrab(NIOUtils.readableChannel(file))
            val vt: DemuxerTrack = grab!!.getVideoTrack()
            val frame_count = vt.getMeta().getTotalFrames()
            val duration = vt.getMeta().getTotalDuration()
            framerate = (1000.0*duration).toLong() / (frame_count).toLong()
            pic_out.setIcon(ImageIcon(getImg()!!))
        }
    }
    private fun getImg(): BufferedImage? {
        try {
            val picture: Picture? = grab?.getNativeFrame()
            if(picture == null) {
                grab?.seekToFramePrecise(0)
                return null
            }
            return toBufferedImage(picture)
        } catch (e: NullPointerException) {
            // jcodec seems to have a bug, and can throw when decoding sometimes
            return null
        }
    }
    fun play(pic_out: JButton) {
        if(playing) {
            playing = false
            playing_task.cancel()
            println("Stopping video playback")
        } else {
            playing = true
            println("Starting video playback")
            playing_task = fixedRateTimer("pic cb", false, 0L, framerate) {
                val img = getImg()
                if (img != null) {
                    pic_out.setIcon(ImageIcon(img))
                    redraw_cell()
                }
            }
        }
    }
    fun clear() {
        playing = false
        playing_task.cancel()
        grab = null
    }
    //Adapted from Jcodec https://github.com/jcodec/jcodec/blob/6e1ec651eca92d21b41f9790143a0e6e4d26811e/javase/src/main/java/org/jcodec/javase/scale/AWTUtil.java
    private fun toBufferedImage(_src: Picture): BufferedImage {
        var src = _src
		if (src.getColor() != ColorSpace.BGR) {
			val bgr = Picture.createCropped(src.getWidth(), src.getHeight(), ColorSpace.BGR, src.getCrop())
			if (src.getColor() == ColorSpace.RGB) {
				RgbToBgr().transform(src, bgr)
			} else {
				val transform = ColorUtil.getTransform(src.getColor(), ColorSpace.RGB)
				transform.transform(src, bgr)
				RgbToBgr().transform(bgr, bgr)
			}
			src = bgr
		}

        var dst = BufferedImage(src.getCroppedWidth(), src.getCroppedHeight(),
                BufferedImage.TYPE_3BYTE_BGR)

        if (src.getCrop() == null)
            toBufferedImage(src, dst);
        else
            toBufferedImageCropped(src, dst);

        return dst
    }
    //Adapted from Jcodec https://github.com/jcodec/jcodec/blob/6e1ec651eca92d21b41f9790143a0e6e4d26811e/javase/src/main/java/org/jcodec/javase/scale/AWTUtil.java
    private fun toBufferedImageCropped(src: Picture, dst: BufferedImage) {
        val data = (dst.getRaster().getDataBuffer() as DataBufferByte).getData();
        val srcData = src.getPlaneData(0);
        val dstStride = dst.getWidth() * 3;
        val srcStride = src.getWidth() * 3;
        var srcOff = 0
        var dstOff = 0
        for (line in  0..dst.getHeight()-1) {
            var _is = srcOff
            var id = dstOff
            while (id < (dstOff + dstStride)) {
                // Unshifting, since JCodec stores [0..255] -> [-128, 127]
                data[id] = (srcData[_is] + 128).toByte()
                data[id + 1] = (srcData[_is + 1] + 128).toByte()
                data[id + 2] = (srcData[_is + 2] + 128).toByte()
                id += 3
                _is += 3
            }
            srcOff += srcStride;
            dstOff += dstStride;
        }
    }
    //Adapted from Jcodec https://github.com/jcodec/jcodec/blob/6e1ec651eca92d21b41f9790143a0e6e4d26811e/javase/src/main/java/org/jcodec/javase/scale/AWTUtil.java
    private fun toBufferedImage(src: Picture, dst: BufferedImage) {
        val _data = (dst.getRaster().getDataBuffer() as DataBufferByte).getData();
        val srcData = src.getPlaneData(0);
        for (i in 0.._data.size-1) {
            // Unshifting, since JCodec stores [0..255] -> [-128, 127]
            _data[i] = (srcData[i] + 128).toByte()
        }
    }
}

sealed class SwingState() {
    abstract fun refresh()
}
class SwingLogin(val transition: (MatrixState, Boolean) -> Unit, val onSync: () -> Unit, val panel: JPanel, val m: MatrixLogin) : SwingState() {
    var c_left = GridBagConstraints()
    var c_right = GridBagConstraints()
    var login_message_label = SmoothLabel(m.login_message)
    var username_field = SmoothTextField(20)
    var username_label = SmoothLabel("Username: ")
    var password_field = JPasswordField(20)
    var password_label = SmoothLabel("Password: ")
    var button = SmoothButton("Login")
    var logIn: (ActionEvent) -> Unit = { transition(m.login(username_field.text, password_field.text, onSync), true) }

    init {
        panel.layout = GridBagLayout()
        c_left.anchor = GridBagConstraints.EAST
        c_left.gridwidth = GridBagConstraints.RELATIVE
        c_left.fill = GridBagConstraints.NONE
        c_left.weightx = 0.0

        c_right.anchor = GridBagConstraints.EAST
        c_right.gridwidth = GridBagConstraints.REMAINDER
        c_right.fill = GridBagConstraints.HORIZONTAL
        c_right.weightx = 1.0

        panel.add(login_message_label, c_right)
        panel.add(SmoothLabel("Login with previous session?"), c_right)

        for (session in m.getSessions()) {
            var button = SmoothButton(session)
            panel.add(button, c_right)
            button.addActionListener({ transition(m.loginFromSession(session, onSync), true) })
        }

        //username_label.labelFor = username_field
        panel.add(username_label, c_left)
        panel.add(username_field, c_right)

        //password_label.labelFor = password_field
        panel.add(password_label, c_left)
        panel.add(password_field, c_right)

        panel.add(button, c_right)

        password_field.addActionListener(logIn)
        button.addActionListener(logIn)
    }
    override fun refresh() {
        // This should change when we have multiple sessions,
        // since it will clear all text input fields on
        // refresh
        transition(m.refresh(), true)
    }
}
/*
class SwingRooms(val transition: (MatrixState, Boolean) -> Unit, val panel: JPanel, var m: MatrixRooms) : SwingState() {
    var message_label = SerifText(m.message)
    var inner_scroll_pane = JPanel()
    init {
        panel.layout = BorderLayout()
        var topPanel = JPanel()
        topPanel.layout = BoxLayout(topPanel, BoxLayout.LINE_AXIS)
        topPanel.add(message_label)
        var newRoomButton = SmoothButton("New Room")
        topPanel.add(newRoomButton)
        newRoomButton.addActionListener({

            val window = SwingUtilities.getWindowAncestor(panel)
            val dim = window.getSize()
            val h = dim.height
            val w = dim.width
            val dialog = JDialog(window, "Create Room")

            val dpanel = JPanel()
            dpanel.layout = BoxLayout(dpanel, BoxLayout.PAGE_AXIS)
            // name, room_alias_name, topic
            var roomname_field = SmoothTextField(20)
            var roomname_label = SmoothLabel("Room Name: ")
            var alias_field = SmoothTextField(20)
            var alias_label = SmoothLabel("Alias: ")
            var topic_field = SmoothTextField(20)
            var topic_label = SmoothLabel("Topic: ")

            val create_btn = SmoothButton("Create")
            create_btn.addActionListener({
                println(m.createRoom(roomname_field.text, alias_field.text, topic_field.text))
                dialog.setVisible(false)
                dialog.dispose()
            })

            val close_btn = SmoothButton("Close")
            close_btn.addActionListener({
                dialog.setVisible(false)
                dialog.dispose()
            })
            dpanel.add(roomname_label)
            dpanel.add(roomname_field)
            dpanel.add(alias_label)
            dpanel.add(alias_field)
            dpanel.add(topic_label)
            dpanel.add(topic_field)
            dpanel.add(create_btn)
            dpanel.add(close_btn)
            dialog.add(dpanel)

            dialog.setSize(w, h / 2)
            dialog.setVisible(true)
            dialog.setResizable(false)
            dialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE)
        })
        panel.add(topPanel, BorderLayout.PAGE_START)

        inner_scroll_pane.layout = GridLayout(0, 1)
        for ((id, name, unreadCount, highlightCount, lastMessage) in m.rooms) {
            var button = JButton()
            button.layout = BoxLayout(button, BoxLayout.PAGE_AXIS)

            val room_name = SerifText("$name ($unreadCount unread / $highlightCount mentions)")
            val last_message = SerifText(lastMessage?.message?.take(80) ?: "")

            button.add(room_name)
            button.add(last_message)

            button.addActionListener({ transition(m.getRoom(id, 20, null, 0), true) })
            inner_scroll_pane.add(button)
        }
        panel.add(JScrollPane(inner_scroll_pane), BorderLayout.CENTER)

        var back_button = SmoothButton("(Fake) Logout")
        panel.add(back_button, BorderLayout.PAGE_END)
        back_button.addActionListener({ transition(m.fake_logout(), true) })
    }
    override fun refresh() {
        transition(m.refresh(), true)
    }
    fun update(new_m: MatrixRooms) {
        if (m.rooms != new_m.rooms) {
            println("Having to transition, rooms !=")
            transition(new_m, false)
        } else {
            message_label.setText(new_m.message)
            m = new_m
        }
    }
}
*/
class ImageFileFilter : FileFilter() {
    override fun accept(f: File): Boolean {
        if (f.isDirectory()) { return true }
        val fname = f.getName()
        val extension = fname.split('.').last().toLowerCase()
        val supported = arrayOf("gif", "png", "jpeg", "jpg")
        return supported.contains(extension)
    }
    override fun getDescription(): String {
        return "Supported Image files"
    }
}

val URL_ATTRIBUTE = object : AttributedCharacterIterator.Attribute("URL_HREF") {}

class URLMouseListener(var message: SerifText) : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) {
        val pos = message.screenToPos(e.x, e.y)
        val char_iter = message.getText().iterator
        if (pos >= 0 && pos < char_iter.endIndex) {
            val debug_char = char_iter.setIndex(pos)
            val href = char_iter.getAttribute(URL_ATTRIBUTE) as String?
            if (href != null) {
                // In the background, so that GUI doesn't freeze
                thread(start = true) {
                    // We have to try using xdg-open first,
                    // since PinePhone somehow implements the
                    // Desktop API but has the same problem with the
                    // GTK_BACKEND var
                    try {
                        println("Trying to open $href with exec 'xdg-open $href'")
                        val pb = ProcessBuilder("xdg-open", href)
                        // Somehow this environment variable gets set for pb
                        // when it's NOT in System.getenv(). And of course, this
                        // is the one that makes xdg-open try to launch an X version
                        // of Firefox, giving the dreaded Firefox is already running
                        // message if you've got a Wayland version running already.
                        pb.environment().clear()
                        pb.environment().putAll(System.getenv())
                        pb.redirectErrorStream(true)
                        val process = pb.start()
                        val reader = BufferedReader(InputStreamReader(process.inputStream))
                        while (reader.readLine() != null) {}
                        process.waitFor()
                        println("done trying to open url")
                    } catch (e1: Exception) {
                        try {
                            println("Trying to open $href with Desktop")
                            java.awt.Desktop.getDesktop().browse(java.net.URI(href))
                        } catch (e2: Exception) {
                            println("Couldn't get ProcessBuilder('xdg-open $href') or Desktop, problem was $e1 then $e2")
                        }
                    }
                }
            }
        }
    }
}

class SmoothLabel(text: String): JLabel(text) {
    override fun paintComponent(g: Graphics) {
        val g2d = g as Graphics2D
        g2d.setRenderingHint(
            RenderingHints.KEY_TEXT_ANTIALIASING,
            RenderingHints.VALUE_TEXT_ANTIALIAS_ON)
        super.paintComponent(g)
    }
}
class SmoothButton(text: String): JButton(text) {
    override fun paintComponent(g: Graphics) {
        val g2d = g as Graphics2D
        g2d.setRenderingHint(
            RenderingHints.KEY_TEXT_ANTIALIASING,
            RenderingHints.VALUE_TEXT_ANTIALIAS_ON)
        super.paintComponent(g)
    }
}
class SmoothTextField(size: Int): JTextField(size) {
    override fun paintComponent(g: Graphics) {
        val g2d = g as Graphics2D
        g2d.setRenderingHint(
            RenderingHints.KEY_TEXT_ANTIALIASING,
            RenderingHints.VALUE_TEXT_ANTIALIAS_ON)
        super.paintComponent(g)
    }
}

class SerifText(private var text: AttributedString) : JComponent() {
    constructor(text: String): this(AttributedString(text))
    private val line_height: Int
    private val max_char_width: Int
    private var size: Dimension
    private var lines: List<Pair<Int,Int>>
    private var max_line_length: Int
    init {
        if (text.iterator.endIndex != 0) {
            text.addAttribute(TextAttribute.SIZE, 16.0)
        }
        val metrics = getFontMetrics(javax.swing.UIManager.getDefaults().getFont("Label.font"))
        line_height = metrics.height
        max_char_width = metrics.charWidth('W')
        lines = calculateLines(text, -1)
        max_line_length = lines.map { it.second - it.first }.max() ?: 1
        size = Dimension(max_char_width * max_line_length, line_height * (lines.size + 1))
    }
    fun calculateLines(text: AttributedString, max_chars_per_line: Int): List<Pair<Int,Int>> {
        val lines: MutableList<Pair<Int,Int>> = mutableListOf()
        var aci = text.iterator
        var begin = aci.index
        val next_break: () -> Int = { ->
            val save = aci.index
            aci.next()
            while (aci.index != aci.endIndex && aci.current() != ' ' && aci.current() != '\n') {
                aci.next()
            }
            val to_ret = aci.index
            aci.index = save
            to_ret
        }
        while (aci.index != aci.endIndex) {
            if (aci.current() == '\n') {
                lines.add(Pair(begin, aci.index))
                begin = aci.index + 1

            // If we have a max length, and either we're at it, or we're at a space and our next line-break oppertunity is beyond
            // the length limit, break
            } else if (max_chars_per_line != -1 && (   (aci.index - begin == max_chars_per_line)
                                                    || (aci.current() == ' ' && next_break() - begin >= max_chars_per_line)) ){
                lines.add(Pair(begin, aci.index + 1))
                begin = aci.index + 1
            }
            aci.next()
        }
        if (begin != aci.index) {
            lines.add(Pair(begin, aci.index))
        }
        return lines
    }
    fun screenToPos(x: Int, y: Int): Int {
        val line_no = min(y / line_height, lines.size-1)
        return lines[line_no].first + (x / max_char_width)
    }
    fun setText(new_text: String) = setText(AttributedString(new_text))
    fun setText(new_text: AttributedString) {
        text = new_text
        if (text.iterator.endIndex != 0) {
            text.addAttribute(TextAttribute.SIZE, 16.0)
        }
        lines = calculateLines(text, size.width / (max_char_width+1))
        max_line_length = lines.map { it.second - it.first }.max() ?: 1
    }
    fun getText() = text
    override fun setSize(d: Dimension) {
        size = d
    }
    override fun setSize(width: Int, height: Int) = setSize(Dimension(width, height))
    override fun getSize() = size
    override fun getPreferredSize() = Dimension(max_char_width * max_line_length,line_height * (lines.size + 1))
    override fun paintComponent(g: Graphics) {
        val g2d = g as Graphics2D
        g2d.setRenderingHint(
            RenderingHints.KEY_TEXT_ANTIALIASING,
            RenderingHints.VALUE_TEXT_ANTIALIAS_ON)
        lines.forEachIndexed { i, line ->
            g2d.drawString(text.getIterator(null, line.first, line.second), 0, (i+1) * line_height)
        }
    }
}

data class RecyclableItemGeneratorResult<T>(val pre_items: List<T>, val sub_components: List<Component>, val post_items: List<T>, val deactivate: () -> Unit, val recycle: (T,() -> Unit) -> Pair<List<T>,List<T>>)
class RecyclingList<T>(private var our_width: Int, val choose: (T) -> String, val make: Map<String, (T,()->Unit) -> RecyclableItemGeneratorResult<T>>, val render_report: (Int,Int)-> Unit) : JComponent(), Scrollable {
    data class RecyclableItem<T>(var start: Int, var end: Int, var indent: Int, val sub_components: List<Component>, val deactivate: ()-> Unit, val recycle: (T,() -> Unit) -> Pair<List<T>,List<T>>)
    val recycle_map: MutableMap<String, ArrayDeque<RecyclableItem<T>>> = mutableMapOf()
    val subs: MutableList<Pair<String, RecyclableItem<T>>> = mutableListOf()
    var current_items: List<T> = listOf()
    var our_height = 0
    var began: Int? = null
    var began_pix: Int? = null
    var ended: Int? = null
    var ended_pix: Int? = null
    init {
        addMouseListener(object : MouseListener, MouseMotionListener {
            fun dispatchEvent(e: MouseEvent) {
                for ((_typ, recycleable) in subs) {
                    val (sy, ey, indent, sub_components, _deactivate, _recycle) = recycleable
                    if ( (sy <= e.point.y)
                       &&(ey >= e.point.y) ) {
                        var sub_offset = sy
                        for (c in sub_components) {
                            if (e.point.y < sub_offset + c.height) {
                                val new_e = MouseEvent(c, e.id, e.getWhen(), e.modifiers, e.x, e.y-sub_offset, e.xOnScreen, e.yOnScreen, e.clickCount, e.isPopupTrigger(), e.button)
                                // a hack so that stuff like buttons have a proper parent when the reply/edit menu pops up and uses it
                                add(c)
                                c.dispatchEvent(new_e)
                                remove(c)
                                return;
                            } else {
                                sub_offset += c.height
                            }
                        }
                    }
                }
            }
            override fun mouseClicked(e: MouseEvent) = dispatchEvent(e)
            override fun mouseEntered(e: MouseEvent) = dispatchEvent(e)
            override fun mouseExited(e: MouseEvent) = dispatchEvent(e)
            override fun mousePressed(e: MouseEvent) = dispatchEvent(e)
            override fun mouseReleased(e: MouseEvent) = dispatchEvent(e)
            override fun mouseDragged(e: MouseEvent) = dispatchEvent(e)
            override fun mouseMoved(e: MouseEvent) = dispatchEvent(e)
        })
    }
    fun cleanup() = reset(1000, listOf())
    fun reset(new_width: Int, items: List<T>) {

        // First, find where the first item in our last drawn range
        // that matches with an item in our new list falls on screen,
        // so that we can scroll the new item to that location.
        var new_idx = -1
        var before_new = 0
        var after_new = 0
        if (ended != null && began != null) {
            before_new += began_pix!!
            after_new -= ended_pix!!
            for (targetIdx in began!!..ended!!) {
                if (targetIdx >= current_items.size)
                    continue
                if (new_idx == -1) {
                    new_idx = items.indexOf(current_items[targetIdx])
                    if (new_idx == -1) {
                        before_new += subs[targetIdx].second.end - subs[targetIdx].second.start
                    }
                } else {
                    after_new += subs[targetIdx].second.end - subs[targetIdx].second.start
                }
            }
        }

        our_height = 0
        our_width = new_width
        for ((typ, recycleable) in subs) {
            recycleable.deactivate()
            recycle_map.getOrPut(typ, { ArrayDeque() }).add(recycleable)
        }
        subs.clear()
        val indent_incr = 100
        fun flatten_into_recyclables(items: List<T>, indent: Int) {
            for (i in items) {
                var height_delta = 0
                val typ = choose(i)
                val our_height_copy = our_height
                val repaint_lambda = { repaint(0, our_height_copy, our_width, height_delta) }
                val possible_recycleable = recycle_map[typ]?.removeLastOrNull()
                val (recycleable, post_items) = if (possible_recycleable != null) {
                    // TODO
                    val (pre_items, post_items) = possible_recycleable.recycle(i, repaint_lambda)
                    flatten_into_recyclables(pre_items, indent + indent_incr)
                    possible_recycleable.start = our_height
                    possible_recycleable.indent = indent
                    Pair(possible_recycleable, post_items)
                } else {
                    println("Creating a new $typ")
                    // TODO
                    val (pre_items, sub_components, post_items, deactivate, recycle) = make[typ]!!(i, repaint_lambda)
                    flatten_into_recyclables(pre_items, indent + indent_incr)
                    Pair(RecyclableItem<T>(our_height, -1, indent, sub_components, deactivate, recycle), post_items)
                }
                for (c in recycleable.sub_components) {
                    c.setSize(our_width, 1000)
                    val d = c.getPreferredSize()
                    val force_width = true
                    if (force_width) {
                        c.setSize(our_width-indent, d.height)
                        c.setBounds(indent, our_height, our_width-indent, d.height)
                    } else {
                        c.setSize(d.width, d.height)
                        c.setBounds(indent, our_height, d.width, d.height)
                    }
                    height_delta += c.height
                }
                recycleable.end = our_height + height_delta
                subs.add(Pair(typ, recycleable))
                our_height += height_delta
                flatten_into_recyclables(post_items, indent + indent_incr)
            }
        }
        flatten_into_recyclables(items, 0)
        current_items = items

        if (new_idx != -1) {
            val new_start = subs[new_idx].second.start
            val new_length = subs[new_idx].second.end - new_start
            val rect = Rectangle(0, new_start - before_new, our_width, new_length + after_new)
            scrollRectToVisible(rect)
        }

        invalidate()
    }
    override fun getPreferredSize() = Dimension(our_width,our_height)
    override fun getPreferredScrollableViewportSize() = Dimension(our_width,our_height)
    override fun getScrollableUnitIncrement(p0: Rectangle, p1: Int, p2: Int) = 10
    override fun getScrollableBlockIncrement(p0: Rectangle, p1: Int, p2: Int) = 100
    override fun getScrollableTracksViewportWidth() = true
    override fun getScrollableTracksViewportHeight() = false
    override fun paintComponent(g: Graphics) {
        val clip_bounds = g.getClipBounds()
        val clip_bounds_ey = clip_bounds.y+clip_bounds.height
        val g = g.create()
        var count = 0
        var total = 0
        var sets = 0
        began = null
        ended = null
        for ((i, typ_recycleable) in subs.withIndex()) {
            val (sy, ey, indent, sub_components, _refresh) = typ_recycleable.second
            if ( (sy <= clip_bounds_ey)
               &&(ey >= clip_bounds.y) ) {
                if (began == null) {
                    began = i
                    began_pix = sy - clip_bounds.y
                }
                ended = i
                ended_pix = ey - clip_bounds_ey
                g.translate(indent, 0)
                for (c in sub_components) {
                    c.paint(g)
                    count += 1
                    g.translate(0, c.height)
                }
                g.translate(-indent, 0)
                sets += 1
            } else {
                g.translate(0, ey-sy)
            }
            total += sub_components.size
        }
        if (began != null && ended != null) {
            render_report(began!!, ended!!)
        }
    }
}

class SwingChatRoom(val transition: (MatrixState, Boolean) -> Unit, val panel: JPanel, var m: MatrixChatRoom, var last_window_width: Int) : SwingState() {
    // From @stephenhay via https://mathiasbynens.be/demo/url-regex
    // slightly modified
    val URL_REGEX = Regex("""(https?|ftp)://[^\s/$.?#].[^\s]*""")
    val stringToAttributedURLString = { s: String ->
        val attString = AttributedString(s)
        for (url_match in URL_REGEX.findAll(s)) {
            attString.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON, url_match.range.start, url_match.range.endInclusive+1)
            attString.addAttribute(URL_ATTRIBUTE, url_match.value, url_match.range.start, url_match.range.endInclusive+1)
        }
        attString
    }
    val room_name = SmoothLabel("")
    fun setRoomName(path: List<String>, name: String) {
        room_name.setText("Path: ${path}, Room Name: $name")
    }
    val mk_sender = { msg: SharedUiMessage ->
        val render_text = { msg: SharedUiMessage ->
            if (msg.reactions.size > 0) {
                "${msg.sender}: ${msg.reactions} "
            } else {
                "${msg.sender}: "
            }
        }
        val sender = SerifText(render_text(msg))
        val set_sender = { msg: SharedUiMessage -> sender.setText(render_text(msg)) }
        set_sender(msg)
        Pair(sender, set_sender)
    }
    val mk_menu = { msg_in: SharedUiMessage  ->
        var msg = msg_in
        val msg_action_button = SmoothButton("...")
        msg_action_button.addActionListener({
            val reply_option = JMenuItem("Reply")
            reply_option.addActionListener({
                println("Now writing a reply")
                replied_event_id = msg.id
            })
            val react_option = JMenuItem("React")
            react_option.addActionListener({
                println("Now writing a reaction")
                reacted_event_id = msg.id
            })
            val edit_option = JMenuItem("Edit")
            edit_option.addActionListener({
                println("Now editing a message")
                edited_event_id = msg.id
                message_field.text = msg.message
            })
            val pin_option = JMenuItem()
            val pin_str = if(m.pinned.contains(msg.id)) { "Unpin" } else { "Pin" }
            pin_option.setText(pin_str)
            pin_option.addActionListener({
                m.togglePinnedEvent(msg.id)
            })
            val show_src_option = JMenuItem("Show Source")
            show_src_option.addActionListener({
                val json_str = m.getEventSrc(msg.id)

                val window = SwingUtilities.getWindowAncestor(panel)
                val dim = window.getSize()
                val h = dim.height
                val w = dim.width
                val dialog = JDialog(window, "Event Source")

                val dpanel = JPanel(BorderLayout())
                val src_txt = JTextPane()
                src_txt.setContentType("text/plain")
                src_txt.setText(json_str)
                src_txt.setEditable(false)

                val close_btn = SmoothButton("Close")
                close_btn.addActionListener({
                    dialog.setVisible(false)
                    dialog.dispose()
                })

                dpanel.add(JScrollPane(src_txt), BorderLayout.CENTER)
                dpanel.add(close_btn,BorderLayout.PAGE_END)
                dialog.add(dpanel)

                dialog.setSize(w,h/2)
                dialog.setVisible(true)
                dialog.setResizable(false)
                dialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE)
            })

            val msg_action_popup = JPopupMenu()
            msg_action_popup.add(reply_option)
            msg_action_popup.add(react_option)
            if(msg.sender.contains(m.username)) {
                msg_action_popup.add(edit_option)
            }
            msg_action_popup.add(pin_option)
            msg_action_popup.add(show_src_option)
            msg_action_popup.show(msg_action_button,0,0)
        })
        Pair(msg_action_button,
            { new_msg: SharedUiMessage -> msg = new_msg; })
    }
    val recycling_message_list = RecyclingList<SharedUiMessage>(last_window_width,
        { when (it) {
                is SharedUiRoom -> "room"
                is SharedUiImgMessage -> "img"
                is SharedUiAudioMessage -> "audio"
                is SharedUiVideoMessage -> "video"
                is SharedUiFileMessage -> "file"
                is SharedUiLocationMessage -> "location"
                else -> "text"
        } },
        mapOf(
            "room" to { msg: SharedUiMessage, repaint_cell ->
                var transition_room_id: String = ""
                val room_btn1 = SmoothButton("")
                val room_btn2 = SmoothButton("")
                val set_click = { msgi: SharedUiRoom ->
                    transition_room_id = msgi.id
                    room_btn1.setText("${msgi.message} (${msgi.unreadCount} unread / ${msgi.highlightCount} mentions)")
                    room_btn2.setText("${msgi.lastMessage?.message?.take(80) ?: ""}")
                }
                set_click(msg as SharedUiRoom)
                room_btn1.addActionListener({
                    transition(m.getRoom(transition_room_id), false)
                })
                room_btn2.addActionListener({
                    transition(m.getRoom(transition_room_id), false)
                })
                RecyclableItemGeneratorResult(
                    listOf(),
                    listOf(room_btn1,room_btn2, JLabel(" ")),
                    listOf(),
                    { Unit },
                    { msg, repaint_cell -> set_click(msg as SharedUiRoom); Pair(listOf(),listOf()) }
                )
            },
            "img" to { msg: SharedUiMessage, repaint_cell ->
                msg as SharedUiImgMessage
                val set_icon_image = { icon: ImageIcon, msg: SharedUiImgMessage, repaint_cell: ()->Unit ->
                    val img_url = msg.url
                    val og_image_icon = ImageIcon(img_url)
                    val og_image = og_image_icon.image
                    val img_width: Int = og_image.getWidth(null)
                    val img_height: Int = og_image.getHeight(null)
                    if (last_window_width != 0 && img_width != 0 && img_height != 0) {
                        val new_width = min(last_window_width, img_width)
                        val new_height = min(img_height, (img_height * new_width)/img_width)
                        icon.setImage(og_image.getScaledInstance(new_width, new_height, Image.SCALE_DEFAULT))
                    } else {
                        icon.setImage(og_image)
                    }
                    icon.setImageObserver(object : ImageObserver {
                        override fun imageUpdate(img: Image, infoFlags: Int, x: Int, y: Int, w: Int, h: Int): Boolean {
                            repaint_cell()
                            return ((infoFlags and (ImageObserver.ALLBITS or ImageObserver.ABORT)) == 0)
                        }
                    })
                }
                val icon = ImageIcon()
                set_icon_image(icon, msg, repaint_cell)
                val (sender, set_sender) = mk_sender(msg)
                val (menu, set_menu) = mk_menu(msg)
                RecyclableItemGeneratorResult(
                    listOf(),
                    listOf(sender, JLabel(icon), menu),
                    listOf(),
                    { icon.setImageObserver(null) }, { msg, repaint_cell ->
                        set_icon_image(icon, msg as SharedUiImgMessage, repaint_cell)
                        set_sender(msg)
                        set_menu(msg)
                        Pair(listOf(), listOf())
                    }
                )
            },
            "audio" to { msg, repaint_cell ->
                msg as SharedUiAudioMessage
                var audio_url = msg.url
                val play_btn = SmoothButton("Play/Pause $audio_url")
                play_btn.addActionListener({
                    AudioPlayer.loadAudio(audio_url)
                    AudioPlayer.play()
                })
                val (sender, set_sender) = mk_sender(msg)
                val (menu, set_menu) = mk_menu(msg)
                RecyclableItemGeneratorResult(
                    listOf(),
                    listOf(sender, play_btn, menu),
                    listOf(),
                    { Unit },
                    { msg, repaint_cell -> set_sender(msg); set_menu(msg); audio_url = (msg as SharedUiAudioMessage).url; Pair(listOf(),listOf()) }
                )
            },
            "video" to { msg, repaint_cell ->
                val video_btn = JButton()
                val pic_chan = ImageIcon()

                val vp = VideoPlayer()
                vp.loadVideo((msg as SharedUiVideoMessage).url, video_btn, repaint_cell)
                video_btn.addActionListener({
                    vp.play(video_btn)
                })

                val (sender, set_sender) = mk_sender(msg)
                val (menu, set_menu) = mk_menu(msg)
                RecyclableItemGeneratorResult(
                    listOf(),
                    listOf(sender, video_btn, menu),
                    listOf(),
                    { vp.clear() },
                    { msg, repaint_cell -> set_sender(msg); set_menu(msg); vp.loadVideo((msg as SharedUiVideoMessage).url, video_btn, repaint_cell); Pair(listOf(),listOf()) }
                )
            },
            "file" to { msg, repaint_cell ->
                var msg = msg as SharedUiFileMessage
                var filename = ""
                val btn = SmoothButton("<file>")
                val set_down = { msgi: SharedUiMessage ->
                    msg = msgi as SharedUiFileMessage
                    filename = if(msg.filename != "") {
                        msg.filename
                    } else {
                        msg.message
                    }
                    btn.setText("Download $filename ${msg.mimetype}")
                }
                set_down(msg)
                btn.addActionListener({
                    val chooser = JFileChooser()
                    chooser.setSelectedFile(File(filename))
                    val ret = chooser.showSaveDialog(btn)
                    if(ret == JFileChooser.APPROVE_OPTION) {
                        val user_file_path = chooser.getSelectedFile().getAbsolutePath()
                        try {
                            m.saveMediaToPath(user_file_path, msg.url)
                        } catch (e: Exception) {
                            println("Couldn't save media, $e")
                        }
                    }
                })
                val (sender, set_sender) = mk_sender(msg)
                val (menu, set_menu) = mk_menu(msg)
                RecyclableItemGeneratorResult(
                    listOf(),
                    listOf(sender, btn, menu),
                    listOf(),
                    { Unit },
                    { msg, repaint_cell -> set_sender(msg); set_menu(msg); set_down(msg); Pair(listOf(),listOf()) }
                )
            },
            "location" to { msg, repaint_cell ->
                val btn = SmoothButton("Location")
                var href = ""
                btn.addActionListener({ openUrl(href) })
                val set_loc = { msg: SharedUiMessage -> 
                    btn.setText("Location: ${msg.message}")
                    val parts = (msg as SharedUiLocationMessage).location.split(",")
                    val lat = parts[0].replace("geo:","")
                    val lon = parts[1]
                    href = "https://maps.google.com/?q=$lat,$lon"
                }
                set_loc(msg)
                val (sender, set_sender) = mk_sender(msg)
                val (menu, set_menu) = mk_menu(msg)
                RecyclableItemGeneratorResult(
                    listOf(),
                    listOf(sender, btn, menu),
                    listOf(),
                    { Unit },
                    { msg, repaint_cell -> set_sender(msg); set_menu(msg); set_loc(msg); Pair(listOf(),listOf()) }
                )
            },
            "text" to { msg, repaint_cell ->
                val message = SerifText(stringToAttributedURLString(msg.message))
                message.addMouseListener(URLMouseListener(message))
                val (sender, set_sender) = mk_sender(msg)
                val (menu, set_menu) = mk_menu(msg)
                RecyclableItemGeneratorResult(
                    msg.replied_event?.let { listOf(it) } ?: listOf(),
                    listOf(sender, message, menu),
                    listOf(),
                    { Unit },
                    { msg, repaint_cell -> message.setText(stringToAttributedURLString(msg.message)); set_sender(msg); set_menu(msg); Pair(msg.replied_event?.let { listOf(it) } ?: listOf(),listOf()) }
                )
            }
        ),
       { began, ended ->
            val drawn_length = ended - began
            val desired_window_half = drawn_length * 3
            val buffer_space = drawn_length
            val in_upper_buffer = began < buffer_space
            val in_lower_buffer = m.messages.size - ended < buffer_space
            val tracking_current = m.message_window_base == null
            val no_request_out = (m.window_back_length + m.window_forward_length + 1) <= m.messages.size
            //println("in_upper_buffer $in_upper_buffer ($began < $buffer_space) && no_request_out $no_request_out (${m.window_back_length} + ${m.window_forward_length} + 1) <= ${m.messages.size}")
            if (in_upper_buffer && no_request_out) {
                javax.swing.SwingUtilities.invokeLater({
                    transition(m.refresh(desired_window_half, m.messages[began].id, desired_window_half), true)
                })
            } else if (in_lower_buffer && !tracking_current) {
                javax.swing.SwingUtilities.invokeLater({
                    transition(m.refresh(desired_window_half, m.messages[min(ended, m.messages.size-1)].id, desired_window_half), true)
                })
            }
        }
    )
    val c_left = GridBagConstraints()
    val c_right = GridBagConstraints()
    val message_field = SmoothTextField(20)
    val pinned_events_btn = SmoothButton("Pinned Events")
    val pinned_action_popup = JPopupMenu()
    var replied_event_id = ""
    var reacted_event_id = ""
    var edited_event_id = ""
    init {
        panel.layout = BorderLayout()
        setRoomName(m.room_ids, m.name)
        val room_header_panel = JPanel()
        room_header_panel.layout = BorderLayout()
        room_header_panel.add(room_name, BorderLayout.LINE_START)
        room_header_panel.add(pinned_events_btn, BorderLayout.CENTER)
        generatePinned(pinned_action_popup)
        pinned_events_btn.addActionListener({ pinned_action_popup.show(pinned_events_btn,0,0) })

        panel.add(
            room_header_panel,
            BorderLayout.PAGE_START
        )

        recycling_message_list.reset(last_window_width, m.messages)
        val scroll_pane = JScrollPane(
            recycling_message_list,
            JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
            JScrollPane.HORIZONTAL_SCROLLBAR_NEVER
        )
        panel.add(
            scroll_pane,
            BorderLayout.CENTER
        )

        val message_panel = JPanel()
        message_panel.layout = BorderLayout()
        var back_button = SmoothButton("Back")
        message_panel.add(back_button, BorderLayout.LINE_START)
        message_panel.add(message_field, BorderLayout.CENTER)
        val msg_panel_actions = JPanel()
        msg_panel_actions.layout = BoxLayout(msg_panel_actions, BoxLayout.LINE_AXIS)
        var attach_button = SmoothButton("+")
        msg_panel_actions.add(attach_button)
        var send_button = SmoothButton("Send")
        msg_panel_actions.add(send_button)
        message_panel.add(msg_panel_actions, BorderLayout.LINE_END)
        panel.add(message_panel, BorderLayout.PAGE_END)
        val onSend: (ActionEvent) -> Unit = {
            val text = message_field.text
            message_field.text = ""
            val res =
                when {
                    replied_event_id == "" && edited_event_id == "" && reacted_event_id == "" -> m.sendMessage(text)
                    replied_event_id != "" -> {
                        val eventid = replied_event_id
                        replied_event_id = ""
                        println("Replying to $eventid")
                        m.sendReply(text, eventid)
                    }
                    reacted_event_id != "" -> {
                        val eventid = reacted_event_id
                        reacted_event_id = ""
                        println("Reacting to $eventid")
                        m.sendReaction(text, eventid)
                    }
                    else -> {
                        val eventid = edited_event_id
                        edited_event_id = ""
                        println("Editing $eventid")
                        m.sendEdit(text, eventid)
                    }
                }
            transition(res, true)
        }
        val onAttach: (ActionEvent) -> Unit = {
            val fc = JFileChooser()
            val iff = ImageFileFilter()
            fc.addChoosableFileFilter(iff)
            fc.setFileFilter(iff)
            val ret = fc.showDialog(panel, "Attach")
            if (ret == JFileChooser.APPROVE_OPTION) {
                val file = fc.getSelectedFile()
                message_field.text = ""
                transition(m.sendImageMessage(file.toPath().toString()), true)
                println("Selected ${file.toPath()}")
            }
        }
        message_field.addActionListener(onSend)
        send_button.addActionListener(onSend)
        attach_button.addActionListener(onAttach)
        back_button.addActionListener({ recycling_message_list.cleanup(); transition(m.exitRoom(), true) })
        m.messages.lastOrNull()?.let { m.sendReceipt(it.id) }
    }
    override fun refresh() {
        transition(m.refresh(), true)
    }
    fun generatePinned(menu: JPopupMenu) {
        while(menu.getComponentCount() > 0) {
            menu.remove(0)
        }
        val pinned_event_previews = m.getPinnedEventPreviews()
        pinned_event_previews.forEach {
            val pinned_option = JMenuItem(it)
            menu.add(pinned_option)
        }
    }
    fun update(new_m: MatrixChatRoom, window_width: Int) {
        if (m.messages != new_m.messages || last_window_width != window_width || !new_m.pinned.equals(m.pinned)) {
            m = new_m
            recycling_message_list.reset(window_width, m.messages)
            last_window_width = window_width
            generatePinned(pinned_action_popup)
        } else {
            m = new_m
        }
        setRoomName(m.room_ids, m.name)
    }
    private fun openUrl(href: String) {
        // In the background, so that GUI doesn't freeze
        thread(start = true) {
            // We have to try using xdg-open first,
            // since PinePhone somehow implements the
            // Desktop API but has the same problem with the
            // GTK_BACKEND var
            try {
                println("Trying to open $href with exec 'xdg-open $href'")
                val pb = ProcessBuilder("xdg-open", href)
                // Somehow this environment variable gets set for pb
                // when it's NOT in System.getenv(). And of course, this
                // is the one that makes xdg-open try to launch an X version
                // of Firefox, giving the dreaded Firefox is already running
                // message if you've got a Wayland version running already.
                pb.environment().clear()
                pb.environment().putAll(System.getenv())
                pb.redirectErrorStream(true)
                val process = pb.start()
                val reader = BufferedReader(InputStreamReader(process.inputStream))
                while (reader.readLine() != null) {}
                process.waitFor()
                println("done trying to open url")
            } catch (e1: Exception) {
                try {
                    println("Trying to open $href with Desktop")
                    java.awt.Desktop.getDesktop().browse(java.net.URI(href))
                } catch (e2: Exception) {
                    println("Couldn't get ProcessBuilder('xdg-open $href') or Desktop, problem was $e1 then $e2")
                }
            }
        }
    }
}

class App {
    var frame = JFrame("Serif")
    var sstate: SwingState
    fun refresh_all() {
        sstate.refresh()
        frame.validate()
        frame.repaint()
    }

    init {
        // Each UI will create it's specific DriverFactory
        // And call this function before the backend can get
        // information out of the database
        Database.initDb(DriverFactory())

        frame.defaultCloseOperation = JFrame.EXIT_ON_CLOSE
        sstate = constructStateView(MatrixLogin())
        frame.pack()
        frame.setVisible(true)
        frame.addComponentListener(object : ComponentAdapter() {
            override fun componentResized(e: ComponentEvent) {
                println("Refresh-alling!")
                refresh_all()
            }
        })
    }

    fun transition(new_state: MatrixState, partial: Boolean) {
        // TODO: update current view if new_state is the same type as mstate
        val s = sstate
        if (partial) {
            when {
                new_state is MatrixChatRoom && s is SwingChatRoom -> { s.update(new_state, frame.width); return; }
                //new_state is MatrixRooms && s is SwingRooms -> { s.update(new_state); return; }
            }
        }
        sstate = constructStateView(new_state)
    }

    fun constructStateView(mstate: MatrixState): SwingState {
        frame.contentPane.removeAll()
        var panel = JPanel()
        val to_ret = when (mstate) {
            is MatrixLogin -> SwingLogin(
                ::transition,
                { javax.swing.SwingUtilities.invokeLater({ refresh_all() }) },
                panel, mstate
            )
            //is MatrixRooms -> SwingRooms(::transition, panel, mstate)
            is MatrixChatRoom -> SwingChatRoom(::transition, panel, mstate, frame.width)
        }
        frame.add(panel)
        frame.validate()
        frame.repaint()
        return to_ret
    }
}

fun main(args: Array<String>) {
    FlatDarkLaf.install()

    val fontStream = object {}.javaClass.getResourceAsStream("iosevka-fixed-extended.ttf")
    val font = Font.createFont(Font.TRUETYPE_FONT, fontStream).deriveFont(16f)
    UIManager.getLookAndFeelDefaults().put("defaultFont", font)
    javax.swing.SwingUtilities.invokeLater({ App() })
}
