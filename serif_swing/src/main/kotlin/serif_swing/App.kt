/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package xyz.room409.serif.serif_swing
import com.formdev.flatlaf.*
import xyz.room409.serif.serif_shared.*
import xyz.room409.serif.serif_shared.db.DriverFactory
import java.awt.*
import java.awt.event.*
import java.util.concurrent.LinkedBlockingQueue
import javax.swing.*
import javax.swing.text.*

sealed class SwingState() {
    abstract fun refresh()
}
class SwingLogin(val transition: (MatrixState, Boolean) -> Unit, val onSync: () -> Unit, val panel: JPanel, val m: MatrixLogin) : SwingState() {
    var c_left = GridBagConstraints()
    var c_right = GridBagConstraints()
    var login_message_label = JLabel(m.login_message)
    var username_field = JTextField(20)
    var username_label = JLabel("Username: ")
    var password_field = JPasswordField(20)
    var password_label = JLabel("Password: ")
    var button = JButton("Login")
    var logIn: (ActionEvent) -> Unit = { transition(m.login(username_field.text, password_field.text, onSync), true) }

    init {
        panel.layout = GridBagLayout()
        c_left.anchor = GridBagConstraints.EAST
        c_left.gridwidth = GridBagConstraints.RELATIVE
        c_left.fill = GridBagConstraints.NONE
        c_left.weightx = 0.0

        c_right.anchor = GridBagConstraints.EAST
        c_right.gridwidth = GridBagConstraints.REMAINDER
        c_right.fill = GridBagConstraints.HORIZONTAL
        c_right.weightx = 1.0

        panel.add(login_message_label, c_right)
        panel.add(JLabel("Login with previous session?"), c_right)

        for (session in m.getSessions()) {
            var button = JButton(session)
            panel.add(button, c_right)
            button.addActionListener({ transition(m.loginFromSession(session, onSync), true) })
        }

        username_label.labelFor = username_field
        panel.add(username_label, c_left)
        panel.add(username_field, c_right)

        password_label.labelFor = password_field
        panel.add(password_label, c_left)
        panel.add(password_field, c_right)

        panel.add(button, c_right)

        password_field.addActionListener(logIn)
        button.addActionListener(logIn)
    }
    override fun refresh() {
        transition(m.refresh(), true)
    }
}
class SwingRooms(val transition: (MatrixState, Boolean) -> Unit, val panel: JPanel, var m: MatrixRooms) : SwingState() {
    var message_label = JLabel(m.message)
    var inner_scroll_pane = JPanel()
    init {
        panel.layout = BoxLayout(panel, BoxLayout.PAGE_AXIS)
        panel.add(message_label)

        inner_scroll_pane.layout = BoxLayout(inner_scroll_pane, BoxLayout.PAGE_AXIS)
        for ((id, name, unreadCount, highlightCount) in m.rooms) {
            var button = JButton("$name - $id - ($unreadCount unread / $highlightCount mentions)")
            inner_scroll_pane.add(button)
            button.addActionListener({ transition(m.getRoom(id), true) })
        }
        panel.add(JScrollPane(inner_scroll_pane))

        var back_button = JButton("(Fake) Logout")
        panel.add(back_button)
        back_button.addActionListener({ transition(m.fake_logout(), true) })
    }
    override fun refresh() {
        transition(m.refresh(), true)
    }
    fun update(new_m: MatrixRooms) {
        if (m.rooms != new_m.rooms) {
            println("Having to transition, rooms !=")
            transition(new_m, false)
        } else {
            message_label.text = new_m.message
            m = new_m
        }
    }
}
class SwingChatRoom(val transition: (MatrixState, Boolean) -> Unit, val panel: JPanel, var m: MatrixChatRoom) : SwingState() {
    var inner_scroll_pane = JPanel()
    var c_left = GridBagConstraints()
    var c_right = GridBagConstraints()
    var message_field = JTextField(20)
    init {
        panel.layout = BoxLayout(panel, BoxLayout.PAGE_AXIS)

        inner_scroll_pane.layout = GridBagLayout()
        c_left.anchor = GridBagConstraints.EAST
        c_left.gridwidth = GridBagConstraints.RELATIVE
        c_left.fill = GridBagConstraints.NONE
        c_left.weightx = 0.0

        c_right.anchor = GridBagConstraints.EAST
        c_right.gridwidth = GridBagConstraints.REMAINDER
        c_right.fill = GridBagConstraints.HORIZONTAL
        c_right.weightx = 1.0

        inner_scroll_pane.layout = BoxLayout(inner_scroll_pane, BoxLayout.PAGE_AXIS)
        for ((sender, message) in m.messages) {
            inner_scroll_pane.add(JLabel("$sender:  "), c_left)
            inner_scroll_pane.add(JLabel(message), c_right)
        }
        panel.add(JScrollPane(inner_scroll_pane))
        panel.add(message_field)
        var send_button = JButton("Send")
        panel.add(send_button)
        val onSend: (ActionEvent) -> Unit = { transition(m.sendMessage(message_field.text), true) }
        message_field.addActionListener(onSend)
        send_button.addActionListener(onSend)

        var back_button = JButton("Back")
        panel.add(back_button)
        back_button.addActionListener({ transition(m.exitRoom(), true) })
    }
    override fun refresh() {
        transition(m.refresh(), true)
    }
    fun update(new_m: MatrixChatRoom) {
        m = new_m
        inner_scroll_pane.removeAll()
        for ((sender, message) in m.messages) {
            inner_scroll_pane.add(JLabel("$sender:  "), c_left)
            inner_scroll_pane.add(JLabel(message), c_right)
        }
    }
}

class App {
    val queue = LinkedBlockingQueue<String>()
    var frame = JFrame("Serif")
    var sstate: SwingState

    init {
        // Each UI will create it's specific DriverFactory
        // And call this function before the backend can get
        // information out of the database
        Database.initDb(DriverFactory())

        frame.defaultCloseOperation = JFrame.EXIT_ON_CLOSE
        sstate = constructStateView(MatrixLogin())
        frame.pack()
        frame.setVisible(true)
    }

    fun transition(new_state: MatrixState, partial: Boolean) {
        // TODO: update current view if new_state is the same type as mstate
        val s = sstate
        if (partial) {
            when {
                new_state is MatrixChatRoom && s is SwingChatRoom -> { s.update(new_state); return; }
                new_state is MatrixRooms && s is SwingRooms -> { s.update(new_state); return; }
            }
        }
        sstate = constructStateView(new_state)
    }

    fun constructStateView(mstate: MatrixState): SwingState {
        frame.contentPane.removeAll()
        var panel = JPanel()
        val to_ret = when (mstate) {
            is MatrixLogin -> SwingLogin(::transition, { sstate.refresh(); frame.validate(); frame.repaint(); }, panel, mstate)
            is MatrixRooms -> SwingRooms(::transition, panel, mstate)
            is MatrixChatRoom -> SwingChatRoom(::transition, panel, mstate)
        }
        frame.add(panel)
        frame.validate()
        frame.repaint()
        return to_ret
    }
}

fun main(args: Array<String>) {
    FlatDarkLaf.install()
    javax.swing.SwingUtilities.invokeLater({ App() })
}
